// This file is automatically generated. DO NOT EDIT!

import Foundation
import SmithereenAPIInternals
import Hammond
extension Friends {

	/// Returns information about friendship states and friend requests related
	/// to the specified users.
	/// - Note: This method requires the following permissions: `friends:read`.
	public struct AreFriends: SmithereenAPIRequest, Hashable, Encodable, Sendable {

		/// The list of user identifiers to retrieve friendship states for.
		public var userIDs: [UserID]

		/// Whether to return ``FriendshipInfo/isRequestUnread``.
		public var extended: Bool

		public struct FriendshipInfo: Hashable, Codable, Sendable {

			/// User identifier.
			public var userID: UserID

			/// The relationship between this user and the current user.
			public var friendStatus: State

			public struct State: Hashable, RawRepresentable, CaseIterable, Codable, Sendable {
				public var rawValue: String
				public init(rawValue: String) {
					self.rawValue = rawValue
				}

				/// No relationship.
				public static let none = Self(rawValue: "none")

				/// Current user is following this user.
				public static let following = Self(rawValue: "following")

				/// This user is following the current user.
				public static let followedBy = Self(rawValue: "followed_by")

				/// Users are friends (they follow each other).
				public static let friends = Self(rawValue: "friends")

				/// Only for remote users – current user tried to follow this
				/// user, but their server hasn’t yet accepted that request
				public static let followRequested = Self(rawValue: "follow_requested")

				public static let allCases: [State] = [
					.none,
					.following,
					.followedBy,
					.friends,
					.followRequested,
				]

				public init(from decoder: Decoder) throws {
					let container = try decoder.singleValueContainer()
					do {
						self = Self(rawValue: try container.decode(String.self))
					} catch DecodingError.typeMismatch {
						let intValue = try container.decode(Int.self)
						switch intValue {
						case 0:
							self = .none
						case 1:
							self = .following
						case 2:
							self = .followedBy
						case 3:
							self = .friends
						default:
							self = Self(rawValue: String(intValue))
						}
					}
				}
			}

			/// Whether there’s an incoming friend request from this user.
			/// Only returned when ``extended`` is `true` and ``friendStatus``
			/// is ``State/followedBy``.
			public var isRequestUnread: Bool?

			public init(
				userID: UserID,
				friendStatus: State,
				isRequestUnread: Bool? = nil,
			) {
				self.userID = userID
				self.friendStatus = friendStatus
				self.isRequestUnread = isRequestUnread
			}

			private enum CodingKeys: String, CodingKey {
				case userID = "user_id"
				case friendStatus = "friend_status"
				case isRequestUnread = "is_request_unread"
			}
		}

		public init(
			userIDs: [UserID],
			extended: Bool,
		) {
			self.userIDs = userIDs
			self.extended = extended
		}

		private enum CodingKeys: String, CodingKey {
			case userIDs = "user_ids"
			case extended
		}
		public var path: String {
			"/api/method/friends.areFriends"
		}
		public static var method: HTTPMethod {
			.post
		}
		public var encodableBody: Self? {
			self
		}
		public typealias Result = [FriendshipInfo]
	}
}