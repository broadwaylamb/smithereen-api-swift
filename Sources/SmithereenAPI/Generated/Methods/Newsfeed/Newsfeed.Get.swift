// This file is automatically generated. DO NOT EDIT!

import Foundation
import SmithereenAPIInternals
import Hammond
extension Newsfeed {

	/// Returns the current user’s followees’ updates (and their own posts).
	/// - Note: This method requires the following permissions: `newsfeed`.
	public struct Get: SmithereenAPIRequest, Hashable, Encodable, Sendable {

		public struct PaginationToken: Identifier {
			public var rawValue: String

			public init(rawValue: String) {
				self.rawValue = rawValue
			}
		}

		/// Which types of updates to return.
		/// By default, updates of all types are returned.
		public var filters: [Filter]?

		public enum Filter: String, Codable, Sendable, CaseIterable {

			/// Wall posts and reposts.
			case post

			/// New photos added to albums.
			case photo

			/// New photo tags.
			case photoTag = "photo_tag"

			/// New friends.
			case friend

			/// Groups joined or created.
			case group

			/// Events joined or created.
			case event

			/// New discussion board topics in groups.
			case board

			/// Relationship status changes
			case relation
		}

		/// Whether to include updates from muted users.
		/// By default `false`.
		public var returnBanned: Bool?

		/// An opaque string required for pagination, returned as
		/// ``Result/nextFrom`` by the previous call of this method.
		/// Don’t pass this parameter when loading the news feed for
		/// the first time or refreshing it.
		public var startFrom: PaginationToken?

		/// How many updates to return, from 0 to 100.
		/// By default 25.
		public var count: Int?

		/// A list of user and group profile fields to return.
		public var fields: [ActorField]?

		/// The information about the relationship status change.
		public struct RelationUpdate: Hashable, Codable, Sendable {

			/// The new relationship status.
			public var status: User.RelationshipStatus

			/// The new partner user identifier, if any.
			public var partner: UserID?

			public init(
				status: User.RelationshipStatus,
				partner: UserID? = nil,
			) {
				self.status = status
				self.partner = partner
			}
		}

		public enum UpdatedItem: Hashable, Codable, Sendable {

			/// A new wall post was created.
			case post(WallPost)

			/// New photos were uploaded.
			case photo(PhotoUpdate)

			/// The user was tagged in some photos.
			case photoTag(PhotoUpdate)

			/// The user added new friends.
			case friend([UserID])

			/// The user joined some groups.
			case groupJoin([GroupID])

			/// The user created some groups.
			case groupCreate([GroupID])

			/// The user joined some events.
			case eventJoin([GroupID])

			/// The user created some events.
			case eventCreate([GroupID])

			/// The user created some discussion board topics.
			case board([BoardTopic])

			/// The user has changed their relationship status.
			case relation(RelationUpdate)

			/// Represents an unrecognized type of payload.
			case unknown(String)

			private enum CodingKeys: String, CodingKey {
				case type
				case post
				case photos
				case friendIDs = "friend_ids"
				case groupIDs = "group_ids"
				case topics
				case relation
			}

			public init(from decoder: Decoder) throws {
				let container = try decoder.container(keyedBy: CodingKeys.self)
				let type = try container.decode(String.self, forKey: .type)
				switch type {
				case "post":
					self = .post(try container.decode(WallPost.self, forKey: .post))
				case "photo":
					self = .photo(try container.decode(PhotoUpdate.self, forKey: .photos))
				case "photo_tag":
					self = .photoTag(try container.decode(PhotoUpdate.self, forKey: .photos))
				case "friend":
					self = .friend(try container.decode([UserID].self, forKey: .friendIDs))
				case "group_join":
					self = .groupJoin(try container.decode([GroupID].self, forKey: .groupIDs))
				case "group_create":
					self = .groupCreate(try container.decode([GroupID].self, forKey: .groupIDs))
				case "event_join":
					self = .eventJoin(try container.decode([GroupID].self, forKey: .groupIDs))
				case "event_create":
					self = .eventCreate(try container.decode([GroupID].self, forKey: .groupIDs))
				case "board":
					self = .board(try container.decode([BoardTopic].self, forKey: .topics))
				case "relation":
					self = .relation(try container.decode(RelationUpdate.self, forKey: .relation))
				default:
					self = .unknown(type)
				}
			}
			public func encode(to encoder: any Encoder) throws {
				var container = encoder.container(keyedBy: CodingKeys.self)
				let tag: String
				switch self {
				case .post(let payload):
					tag = "post"
					try container.encode(payload, forKey: .post)
				case .photo(let payload):
					tag = "photo"
					try container.encode(payload, forKey: .photos)
				case .photoTag(let payload):
					tag = "photo_tag"
					try container.encode(payload, forKey: .photos)
				case .friend(let payload):
					tag = "friend"
					try container.encode(payload, forKey: .friendIDs)
				case .groupJoin(let payload):
					tag = "group_join"
					try container.encode(payload, forKey: .groupIDs)
				case .groupCreate(let payload):
					tag = "group_create"
					try container.encode(payload, forKey: .groupIDs)
				case .eventJoin(let payload):
					tag = "event_join"
					try container.encode(payload, forKey: .groupIDs)
				case .eventCreate(let payload):
					tag = "event_create"
					try container.encode(payload, forKey: .groupIDs)
				case .board(let payload):
					tag = "board"
					try container.encode(payload, forKey: .topics)
				case .relation(let payload):
					tag = "relation"
					try container.encode(payload, forKey: .relation)
				case .unknown(let _tag):
					tag = _tag
				}
				try container.encode(tag, forKey: .type)
			}
		}

		public struct UpdateID: Identifier {
			public var rawValue: Int

			public init(rawValue: Int) {
				self.rawValue = rawValue
			}
		}

		public struct Update: Hashable, Codable, Sendable, Identifiable {
			public var item: UpdatedItem

			/// Identifier of this update.
			public var id: UpdateID

			/// Which user this update is about.
			public var userID: UserID

			public init(
				item: UpdatedItem,
				id: UpdateID,
				userID: UserID,
			) {
				self.item = item
				self.id = id
				self.userID = userID
			}

			private enum CodingKeys: String, CodingKey {
				case id
				case userID = "user_id"
			}
			public func encode(to encoder: any Encoder) throws {
				var container = encoder.container(keyedBy: CodingKeys.self)
				try self.item.encode(to: encoder)
				try container.encode(self.id, forKey: .id)
				try container.encode(self.userID, forKey: .userID)
			}

			public init(from decoder: Decoder) throws {
				let container = try decoder.container(keyedBy: CodingKeys.self)
				self.item = try UpdatedItem(from: decoder)
				self.id = try container.decode(UpdateID.self, forKey: .id)
				self.userID = try container.decode(UserID.self, forKey: .userID)
			}
		}

		public struct Result: Hashable, Codable, Sendable {

			/// The updates themselves.
			public var items: [Update]

			/// User objects relevant to these updates.
			public var profiles: [User]

			/// Group objects relevant to these updates.
			public var groups: [Group]

			/// The value to pass as ``startFrom`` in a subsequent call to
			/// this method to load the next page of the news feed.
			/// If this field is absent, no more updates are available.
			public var nextFrom: PaginationToken?

			public init(
				items: [Update],
				profiles: [User],
				groups: [Group],
				nextFrom: PaginationToken? = nil,
			) {
				self.items = items
				self.profiles = profiles
				self.groups = groups
				self.nextFrom = nextFrom
			}

			private enum CodingKeys: String, CodingKey {
				case items
				case profiles
				case groups
				case nextFrom = "next_from"
			}
		}

		public init(
			filters: [Filter]? = nil,
			returnBanned: Bool? = nil,
			startFrom: PaginationToken? = nil,
			count: Int? = nil,
			fields: [ActorField]? = nil,
		) {
			self.filters = filters
			self.returnBanned = returnBanned
			self.startFrom = startFrom
			self.count = count
			self.fields = fields
		}

		private enum CodingKeys: String, CodingKey {
			case filters
			case returnBanned = "return_banned"
			case startFrom = "start_from"
			case count
			case fields
		}
		public var path: String {
			"/api/method/newsfeed.get"
		}
		public static var method: HTTPMethod {
			.post
		}
		public var encodableBody: Self {
			self
		}
	}
}