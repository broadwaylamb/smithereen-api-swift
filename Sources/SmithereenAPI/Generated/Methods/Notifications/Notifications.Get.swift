// This file is automatically generated. DO NOT EDIT!

import Foundation
import SmithereenAPIInternals
extension Notifications {

	/// Returns the current user's notifications.
	/// 
	/// - Note: This method requires the following permissions: `notifications`.
	public struct Get: SmithereenAPIRequest, Hashable, Encodable, Sendable {

		/// Offset into the notification list for pagination.
		public var offset: Int?

		/// How many notifications to return.
		/// 
		/// Minumum value: 1. Maximum value: 100. By default 50.
		public var count: Int?

		/// The identifier of the most recent notification known to
		/// the client. Use this to get a consistent view of the list
		/// even if new notifications were added between requests for
		/// subsequent pages.
		public var maxID: NotificationID?

		public struct Notification: Hashable, Codable, Sendable, Identifiable {

			/// Identifier of this notification.
			/// The newer the notification, the greater the identifier.
			public var id: NotificationID
			public var event: Event

			/// The time when this notification was created.
			@UnixTimestamp
			public var date: Date

			/// - parameters:
			///   - id: Identifier of this notification.
			///     The newer the notification, the greater the identifier.
			///   - date: The time when this notification was created.
			public init(
				id: NotificationID,
				event: Event,
				date: Date,
			) {
				self.id = id
				self.event = event
				self.date = date
			}

			private enum CodingKeys: String, CodingKey {
				case id
				case date
			}
			public func encode(to encoder: any Encoder) throws {
				var container = encoder.container(keyedBy: CodingKeys.self)
				try container.encode(self.id, forKey: .id)
				try self.event.encode(to: encoder)
				try container.encode(self.date, forKey: .date)
			}

			public init(from decoder: Decoder) throws {
				let container = try decoder.container(keyedBy: CodingKeys.self)
				self.id = try container.decode(NotificationID.self, forKey: .id)
				self.event = try Event(from: decoder)
				self.date = try container.decode(Date.self, forKey: .date)
			}
		}

		/// - parameters:
		///   - offset: Offset into the notification list for pagination.
		///   - count: How many notifications to return.
		///     
		///     Minumum value: 1. Maximum value: 100. By default 50.
		///   - maxID: The identifier of the most recent notification known to
		///     the client. Use this to get a consistent view of the list
		///     even if new notifications were added between requests for
		///     subsequent pages.
		public init(
			offset: Int? = nil,
			count: Int? = nil,
			maxID: NotificationID? = nil,
		) {
			self.offset = offset
			self.count = count
			self.maxID = maxID
		}

		private enum CodingKeys: String, CodingKey {
			case offset
			case count
			case maxID = "max_id"
		}
		public var path: String {
			"/api/method/notifications.get"
		}
		public static var method: HTTPMethod {
			.post
		}
		public var encodableBody: Self? {
			self
		}
	}
}
extension Notifications.Get.Event {

	/// For groupable notifications: information about users that did
	/// the action.
	public struct UserIDs: Hashable, Codable, Sendable {

		/// How many users there are total.
		public var count: Int

		/// Identifiers of the most recent 10 users.
		public var items: [UserID]

		/// - parameters:
		///   - count: How many users there are total.
		///   - items: Identifiers of the most recent 10 users.
		public init(
			count: Int,
			items: [UserID],
		) {
			self.count = count
			self.items = items
		}
	}
}