// This file is automatically generated. DO NOT EDIT!

import Foundation
import SmithereenAPIInternals

/// A private message.
public struct Message: Hashable, Codable, Sendable, Identifiable {

	/// Unique (server-wide) identifier of this message.
	public var id: MessageID

	/// Globally unique ActivityPub identifier for this message.
	/// Use this to match messages across servers.
	public var activityPubID: URL

	/// Identifier of the user who sent this message.
	public var from: UserID

	/// Identifiers of primary recipients of this message.
	public var to: [UserID]

	/// Identifiers of secondary recipients of this message.
	public var cc: [UserID]

	/// Timestamp when this message was sent.
	@UnixTimestamp
	public var date: Date

	/// Identifiers of recipients who have read (opened) this message.
	/// 
	/// Read receipts are currently only supported by Smithereen,
	/// so users from servers running different software wonâ€™t
	/// show up here.
	public var readBy: [UserID]

	/// The subject line.
	public var subject: String

	/// The main text of the message as HTML.
	public var body: String

	/// Media attachments added to this message.
	public var attachments: [Attachment]?

	/// If this message is in reply to something, information about
	/// that object.
	/// 
	/// Mastodon and most other similar microblogging-style software
	/// represents private messages as posts with limited visibility,
	/// thus allowing its users to reply to public content in private.
	public var replyTo: ReplyInfo?

	public enum ReplyInfo: Hashable, Codable, Sendable {

		/// This is a private reply to a wall post
		case wallPost(WallPostID)

		/// This is a private reply to a comment on a wall post.
		case wallComment(WallPostID)

		/// This is a reply to another private message.
		case message(MessageID)

		private enum CodingKeys: String, CodingKey {
			case type
			case wallPostID = "wall_post_id"
			case wallCommentID = "wall_comment_id"
			case messageID = "message_id"
		}

		public init(from decoder: Decoder) throws {
			let container = try decoder.container(keyedBy: CodingKeys.self)
			let type = try container.decode(String.self, forKey: .type)
			switch type {
			case "wall_post":
				self = .wallPost(try container.decode(WallPostID.self, forKey: .wallPostID))
			case "wall_comment":
				self = .wallComment(try container.decode(WallPostID.self, forKey: .wallCommentID))
			case "message":
				self = .message(try container.decode(MessageID.self, forKey: .messageID))
			default:
				throw DecodingError.dataCorruptedError(
					forKey: .type,
					in: container,
					debugDescription: "Unknown payload type",
				)
			}
		}
		public func encode(to encoder: any Encoder) throws {
			var container = encoder.container(keyedBy: CodingKeys.self)
			let tag: String
			switch self {
			case .wallPost(let payload):
				tag = "wall_post"
				try container.encode(payload, forKey: .wallPostID)
			case .wallComment(let payload):
				tag = "wall_comment"
				try container.encode(payload, forKey: .wallCommentID)
			case .message(let payload):
				tag = "message"
				try container.encode(payload, forKey: .messageID)
			}
			try container.encode(tag, forKey: .type)
		}
	}

	public init(
		id: MessageID,
		activityPubID: URL,
		from: UserID,
		to: [UserID],
		cc: [UserID],
		date: Date,
		readBy: [UserID],
		subject: String,
		body: String,
		attachments: [Attachment]? = nil,
		replyTo: ReplyInfo? = nil,
	) {
		self.id = id
		self.activityPubID = activityPubID
		self.from = from
		self.to = to
		self.cc = cc
		self.date = date
		self.readBy = readBy
		self.subject = subject
		self.body = body
		self.attachments = attachments
		self.replyTo = replyTo
	}

	private enum CodingKeys: String, CodingKey {
		case id
		case activityPubID = "ap_id"
		case from
		case to
		case cc
		case date
		case readBy = "read_by"
		case subject
		case body
		case attachments
		case replyTo = "reply_to"
	}
}