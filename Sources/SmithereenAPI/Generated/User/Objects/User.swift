// This file is automatically generated. DO NOT EDIT!

import Foundation
import SmithereenAPIInternals

public struct User: Hashable, Codable, Sendable, Identifiable {
	public var id: UserID
	public var firstName: String
	public var lastName: String?
	public var deactivated: DeactivatedStatus?

	public struct DeactivatedStatus: Hashable, RawRepresentable, CaseIterable, Codable, Sendable {
		public var rawValue: String
		public init(rawValue: String) {
			self.rawValue = rawValue
		}

		public static let banned = Self(rawValue: "banned")
		public static let hidden = Self(rawValue: "hidden")
		public static let deleted = Self(rawValue: "deleted")

		public static let allCases: [DeactivatedStatus] = [
			.banned,
			.hidden,
			.deleted,
		]
	}

	/// Always non-nil for Smithereen, always nil for OpenVK
	public var activityPubID: URL?
	public var domain: String?
	public var screenName: String?
	public var status: String?
	public var url: URL?
	public var nickname: String?
	public var maidenName: String?
	public var sex: Gender?

	public struct Gender: Hashable, RawRepresentable, CaseIterable, Codable, Sendable {
		public var rawValue: String
		public init(rawValue: String) {
			self.rawValue = rawValue
		}

		public static let other = Self(rawValue: "other")
		public static let female = Self(rawValue: "female")
		public static let male = Self(rawValue: "male")

		public static let allCases: [Gender] = [
			.other,
			.female,
			.male,
		]

		public init(from decoder: Decoder) throws {
			let container = try decoder.singleValueContainer()
			do {
				self = Self(rawValue: try container.decode(String.self))
			} catch DecodingError.typeMismatch {
				let intValue = try container.decode(Int.self)
				switch intValue {
				case 0:
					self = .other
				case 1:
					self = .female
				case 2:
					self = .male
				default:
					self = Self(rawValue: String(intValue))
				}
			}
		}
	}
	public var birthday: Birthday?
	public var homeTown: String?
	public var relation: RelationshipStatus?

	public struct RelationshipStatus: Hashable, RawRepresentable, CaseIterable, Codable, Sendable {
		public var rawValue: String
		public init(rawValue: String) {
			self.rawValue = rawValue
		}

		public static let single = Self(rawValue: "single")
		public static let inRelationship = Self(rawValue: "in_relationship")
		public static let engaged = Self(rawValue: "engaged")
		public static let married = Self(rawValue: "married")
		public static let complicated = Self(rawValue: "complicated")
		public static let activelySearching = Self(rawValue: "actively_searching")
		public static let inLove = Self(rawValue: "in_love")

		/// OpenVK only, not supported in Smithereen
		public static let inCivilMarriage = Self(rawValue: "in_civil_marriage")

		public static let allCases: [RelationshipStatus] = [
			.single,
			.inRelationship,
			.engaged,
			.married,
			.complicated,
			.activelySearching,
			.inLove,
			.inCivilMarriage,
		]

		public init(from decoder: Decoder) throws {
			let container = try decoder.singleValueContainer()
			do {
				self = Self(rawValue: try container.decode(String.self))
			} catch DecodingError.typeMismatch {
				let intValue = try container.decode(Int.self)
				switch intValue {
				case 1:
					self = .single
				case 2:
					self = .inRelationship
				case 3:
					self = .engaged
				case 4:
					self = .married
				case 5:
					self = .complicated
				case 6:
					self = .activelySearching
				case 7:
					self = .inLove
				case 8:
					self = .inCivilMarriage
				default:
					self = Self(rawValue: String(intValue))
				}
			}
		}
	}
	public var relationPartner: RelationshipPartner?

	public struct RelationshipPartner: Hashable, Codable, Sendable {
		public var id: UserID
		public var name: String

		public init(
			id: UserID,
			name: String,
		) {
			self.id = id
			self.name = name
		}
	}
	public var customProfileFields: [CustomProfileField]?

	public struct CustomProfileField: Hashable, Codable, Sendable {
		public var name: String
		public var value: String

		public init(
			name: String,
			value: String,
		) {
			self.name = name
			self.value = value
		}
	}
	public var city: String?
	public var matrix: String?
	public var xmpp: String?
	public var telegram: String?
	public var signal: String?
	public var twitter: String?
	public var instagram: String?
	public var facebook: String?
	public var vkontakte: String?
	public var snapchat: String?
	public var discord: String?
	public var mastodon: String?
	public var pixelfed: String?
	public var phoneNumber: String?
	public var email: String?
	public var git: URL?
	public var site: URL?
	public var activities: String?
	public var interests: String?
	public var music: String?
	public var movies: String?
	public var tv: String?
	public var books: String?
	public var games: String?
	public var quotes: String?
	public var about: String?
	public var personal: PersonalViews?

	public struct PersonalViews: Hashable, Codable, Sendable {
		public var political: PoliticalViews?
		public var religion: String?
		public var inspiredBy: String?
		public var peopleMain: PeoplePriority?
		public var lifeMain: PersonalPriority?
		public var smoking: HabitsViews?
		public var alcohol: HabitsViews?

		public init(
			political: PoliticalViews? = nil,
			religion: String? = nil,
			inspiredBy: String? = nil,
			peopleMain: PeoplePriority? = nil,
			lifeMain: PersonalPriority? = nil,
			smoking: HabitsViews? = nil,
			alcohol: HabitsViews? = nil,
		) {
			self.political = political
			self.religion = religion
			self.inspiredBy = inspiredBy
			self.peopleMain = peopleMain
			self.lifeMain = lifeMain
			self.smoking = smoking
			self.alcohol = alcohol
		}

		private enum CodingKeys: String, CodingKey {
			case political
			case religion
			case inspiredBy = "inspired_by"
			case peopleMain = "people_main"
			case lifeMain = "life_main"
			case smoking
			case alcohol
		}
	}

	public struct PoliticalViews: Hashable, RawRepresentable, CaseIterable, Codable, Sendable {
		public var rawValue: String
		public init(rawValue: String) {
			self.rawValue = rawValue
		}

		public static let communist = Self(rawValue: "communist")
		public static let socialist = Self(rawValue: "socialist")
		public static let moderate = Self(rawValue: "moderate")
		public static let liberal = Self(rawValue: "liberal")
		public static let conservative = Self(rawValue: "conservative")
		public static let monarchist = Self(rawValue: "monarchist")
		public static let ultraconservative = Self(rawValue: "ultraconservative")
		public static let apathetic = Self(rawValue: "apathetic")
		public static let libertarian = Self(rawValue: "libertarian")

		public static let allCases: [PoliticalViews] = [
			.communist,
			.socialist,
			.moderate,
			.liberal,
			.conservative,
			.monarchist,
			.ultraconservative,
			.apathetic,
			.libertarian,
		]

		public init(from decoder: Decoder) throws {
			let container = try decoder.singleValueContainer()
			do {
				self = Self(rawValue: try container.decode(String.self))
			} catch DecodingError.typeMismatch {
				let intValue = try container.decode(Int.self)
				switch intValue {
				case 1:
					self = .communist
				case 2:
					self = .socialist
				case 3:
					self = .moderate
				case 4:
					self = .liberal
				case 5:
					self = .conservative
				case 6:
					self = .monarchist
				case 7:
					self = .ultraconservative
				case 8:
					self = .apathetic
				case 9:
					self = .libertarian
				default:
					self = Self(rawValue: String(intValue))
				}
			}
		}
	}

	public struct PeoplePriority: Hashable, RawRepresentable, CaseIterable, Codable, Sendable {
		public var rawValue: String
		public init(rawValue: String) {
			self.rawValue = rawValue
		}

		public static let intellectCreativity = Self(rawValue: "intellect_creativity")
		public static let kindnessHonesty = Self(rawValue: "kindness_honesty")
		public static let healthBeauty = Self(rawValue: "health_beauty")
		public static let wealthPower = Self(rawValue: "wealth_power")
		public static let couragePersistence = Self(rawValue: "courage_persistence")
		public static let humorLifeLove = Self(rawValue: "humor_life_love")

		public static let allCases: [PeoplePriority] = [
			.intellectCreativity,
			.kindnessHonesty,
			.healthBeauty,
			.wealthPower,
			.couragePersistence,
			.humorLifeLove,
		]

		public init(from decoder: Decoder) throws {
			let container = try decoder.singleValueContainer()
			do {
				self = Self(rawValue: try container.decode(String.self))
			} catch DecodingError.typeMismatch {
				let intValue = try container.decode(Int.self)
				switch intValue {
				case 1:
					self = .intellectCreativity
				case 2:
					self = .kindnessHonesty
				case 3:
					self = .healthBeauty
				case 4:
					self = .wealthPower
				case 5:
					self = .couragePersistence
				case 6:
					self = .humorLifeLove
				default:
					self = Self(rawValue: String(intValue))
				}
			}
		}
	}

	public struct PersonalPriority: Hashable, RawRepresentable, CaseIterable, Codable, Sendable {
		public var rawValue: String
		public init(rawValue: String) {
			self.rawValue = rawValue
		}

		public static let familyChildren = Self(rawValue: "family_children")
		public static let careerMoney = Self(rawValue: "career_money")
		public static let entertainmentLeisure = Self(rawValue: "entertainment_leisure")
		public static let scienceResearch = Self(rawValue: "science_research")
		public static let improvingWorld = Self(rawValue: "improving_world")
		public static let personalDevelopment = Self(rawValue: "personal_development")
		public static let beautyArt = Self(rawValue: "beauty_art")
		public static let fameInfluence = Self(rawValue: "fame_influence")

		public static let allCases: [PersonalPriority] = [
			.familyChildren,
			.careerMoney,
			.entertainmentLeisure,
			.scienceResearch,
			.improvingWorld,
			.personalDevelopment,
			.beautyArt,
			.fameInfluence,
		]

		public init(from decoder: Decoder) throws {
			let container = try decoder.singleValueContainer()
			do {
				self = Self(rawValue: try container.decode(String.self))
			} catch DecodingError.typeMismatch {
				let intValue = try container.decode(Int.self)
				switch intValue {
				case 1:
					self = .familyChildren
				case 2:
					self = .careerMoney
				case 3:
					self = .entertainmentLeisure
				case 4:
					self = .scienceResearch
				case 5:
					self = .improvingWorld
				case 6:
					self = .personalDevelopment
				case 7:
					self = .beautyArt
				case 8:
					self = .fameInfluence
				default:
					self = Self(rawValue: String(intValue))
				}
			}
		}
	}

	public struct HabitsViews: Hashable, RawRepresentable, CaseIterable, Codable, Sendable {
		public var rawValue: String
		public init(rawValue: String) {
			self.rawValue = rawValue
		}

		public static let veryNegative = Self(rawValue: "very_negative")
		public static let negative = Self(rawValue: "negative")
		public static let tolerant = Self(rawValue: "tolerant")
		public static let neutral = Self(rawValue: "neutral")
		public static let positive = Self(rawValue: "positive")

		public static let allCases: [HabitsViews] = [
			.veryNegative,
			.negative,
			.tolerant,
			.neutral,
			.positive,
		]

		public init(from decoder: Decoder) throws {
			let container = try decoder.singleValueContainer()
			do {
				self = Self(rawValue: try container.decode(String.self))
			} catch DecodingError.typeMismatch {
				let intValue = try container.decode(Int.self)
				switch intValue {
				case 1:
					self = .veryNegative
				case 2:
					self = .negative
				case 3:
					self = .tolerant
				case 4:
					self = .neutral
				case 5:
					self = .positive
				default:
					self = Self(rawValue: String(intValue))
				}
			}
		}
	}

	@LenientBool
	public var online: Bool?

	@LenientBool
	public var onlineMobile: Bool?
	public var lastSeen: LastSeen?

	public struct LastSeen: Hashable, Codable, Sendable {

		@UnixTimestamp
		public var time: Date
		public var platform: Platform

		public init(
			time: Date,
			platform: Platform,
		) {
			self.time = time
			self.platform = platform
		}
	}

	@LenientBool
	public var blocked: Bool?

	@LenientBool
	public var blockedByMe: Bool?

	@LenientBool
	public var canPost: Bool?

	@LenientBool
	public var canSeeAllPosts: Bool?

	@LenientBool
	public var canSendFriendRequest: Bool?

	@LenientBool
	public var canWritePrivateMessage: Bool?
	public var mutualCount: Int?
	public var friendStatus: FriendStatus?

	public struct FriendStatus: Hashable, RawRepresentable, CaseIterable, Codable, Sendable {
		public var rawValue: String
		public init(rawValue: String) {
			self.rawValue = rawValue
		}

		public static let none = Self(rawValue: "none")
		public static let following = Self(rawValue: "following")
		public static let followedBy = Self(rawValue: "followed_by")
		public static let friends = Self(rawValue: "friends")
		public static let followRequested = Self(rawValue: "follow_requested")

		public static let allCases: [FriendStatus] = [
			.none,
			.following,
			.followedBy,
			.friends,
			.followRequested,
		]

		public init(from decoder: Decoder) throws {
			let container = try decoder.singleValueContainer()
			do {
				self = Self(rawValue: try container.decode(String.self))
			} catch DecodingError.typeMismatch {
				let intValue = try container.decode(Int.self)
				switch intValue {
				case 0:
					self = .none
				case 1:
					self = .following
				case 2:
					self = .followedBy
				case 3:
					self = .friends
				default:
					self = Self(rawValue: String(intValue))
				}
			}
		}
	}

	@LenientBool
	public var isFriend: Bool?

	@LenientBool
	public var isFavorite: Bool?
	public var lists: [FriendListID]?

	@LenientBool
	public var isHiddenFromFeed: Bool?
	public var followersCount: Int?

	@LenientBool
	public var isNoIndex: Bool?
	public var wallDefault: WallMode?

	public enum WallMode: String, Codable, Sendable {
		case owner
		case all
	}
	public var photo50: URL?
	public var photo100: URL?
	public var photo200: URL?
	public var photo400: URL?
	public var photoMax: URL?
	public var photo200Orig: URL?
	public var photo400Orig: URL?
	public var photoMaxOrig: URL?
	public var photoId: PhotoID?
	public var timezone: TimeZone?
	public var firstNameNom: String?
	public var nicknameNom: String?
	public var lastNameNom: String?
	public var firstNameGen: String?
	public var nicknameGen: String?
	public var lastNameGen: String?
	public var firstNameDat: String?
	public var nicknameDat: String?
	public var lastNameDat: String?
	public var firstNameAcc: String?
	public var nicknameAcc: String?
	public var lastNameAcc: String?
	public var firstNameIns: String?
	public var nicknameIns: String?
	public var lastNameIns: String?
	public var firstNameAbl: String?
	public var nicknameAbl: String?
	public var lastNameAbl: String?
	public var counters: Counters?

	public struct Counters: Hashable, Codable, Sendable {
		public var albums: Int
		public var photos: Int
		public var friends: Int
		public var groups: Int
		public var onlineFriends: Int
		public var mutualFriends: Int
		public var userPhotos: Int
		public var followers: Int
		public var subscriptions: Int

		public init(
			albums: Int,
			photos: Int,
			friends: Int,
			groups: Int,
			onlineFriends: Int,
			mutualFriends: Int,
			userPhotos: Int,
			followers: Int,
			subscriptions: Int,
		) {
			self.albums = albums
			self.photos = photos
			self.friends = friends
			self.groups = groups
			self.onlineFriends = onlineFriends
			self.mutualFriends = mutualFriends
			self.userPhotos = userPhotos
			self.followers = followers
			self.subscriptions = subscriptions
		}

		private enum CodingKeys: String, CodingKey {
			case albums
			case photos
			case friends
			case groups
			case onlineFriends = "online_friends"
			case mutualFriends = "mutual_friends"
			case userPhotos = "user_photos"
			case followers
			case subscriptions
		}
	}

	public init(
		id: UserID,
		firstName: String,
		lastName: String? = nil,
		deactivated: DeactivatedStatus? = nil,
		activityPubID: URL? = nil,
		domain: String? = nil,
		screenName: String? = nil,
		status: String? = nil,
		url: URL? = nil,
		nickname: String? = nil,
		maidenName: String? = nil,
		sex: Gender? = nil,
		birthday: Birthday? = nil,
		homeTown: String? = nil,
		relation: RelationshipStatus? = nil,
		relationPartner: RelationshipPartner? = nil,
		customProfileFields: [CustomProfileField]? = nil,
		city: String? = nil,
		matrix: String? = nil,
		xmpp: String? = nil,
		telegram: String? = nil,
		signal: String? = nil,
		twitter: String? = nil,
		instagram: String? = nil,
		facebook: String? = nil,
		vkontakte: String? = nil,
		snapchat: String? = nil,
		discord: String? = nil,
		mastodon: String? = nil,
		pixelfed: String? = nil,
		phoneNumber: String? = nil,
		email: String? = nil,
		git: URL? = nil,
		site: URL? = nil,
		activities: String? = nil,
		interests: String? = nil,
		music: String? = nil,
		movies: String? = nil,
		tv: String? = nil,
		books: String? = nil,
		games: String? = nil,
		quotes: String? = nil,
		about: String? = nil,
		personal: PersonalViews? = nil,
		online: Bool? = nil,
		onlineMobile: Bool? = nil,
		lastSeen: LastSeen? = nil,
		blocked: Bool? = nil,
		blockedByMe: Bool? = nil,
		canPost: Bool? = nil,
		canSeeAllPosts: Bool? = nil,
		canSendFriendRequest: Bool? = nil,
		canWritePrivateMessage: Bool? = nil,
		mutualCount: Int? = nil,
		friendStatus: FriendStatus? = nil,
		isFriend: Bool? = nil,
		isFavorite: Bool? = nil,
		lists: [FriendListID]? = nil,
		isHiddenFromFeed: Bool? = nil,
		followersCount: Int? = nil,
		isNoIndex: Bool? = nil,
		wallDefault: WallMode? = nil,
		photo50: URL? = nil,
		photo100: URL? = nil,
		photo200: URL? = nil,
		photo400: URL? = nil,
		photoMax: URL? = nil,
		photo200Orig: URL? = nil,
		photo400Orig: URL? = nil,
		photoMaxOrig: URL? = nil,
		photoId: PhotoID? = nil,
		timezone: TimeZone? = nil,
		firstNameNom: String? = nil,
		nicknameNom: String? = nil,
		lastNameNom: String? = nil,
		firstNameGen: String? = nil,
		nicknameGen: String? = nil,
		lastNameGen: String? = nil,
		firstNameDat: String? = nil,
		nicknameDat: String? = nil,
		lastNameDat: String? = nil,
		firstNameAcc: String? = nil,
		nicknameAcc: String? = nil,
		lastNameAcc: String? = nil,
		firstNameIns: String? = nil,
		nicknameIns: String? = nil,
		lastNameIns: String? = nil,
		firstNameAbl: String? = nil,
		nicknameAbl: String? = nil,
		lastNameAbl: String? = nil,
		counters: Counters? = nil,
	) {
		self.id = id
		self.firstName = firstName
		self.lastName = lastName
		self.deactivated = deactivated
		self.activityPubID = activityPubID
		self.domain = domain
		self.screenName = screenName
		self.status = status
		self.url = url
		self.nickname = nickname
		self.maidenName = maidenName
		self.sex = sex
		self.birthday = birthday
		self.homeTown = homeTown
		self.relation = relation
		self.relationPartner = relationPartner
		self.customProfileFields = customProfileFields
		self.city = city
		self.matrix = matrix
		self.xmpp = xmpp
		self.telegram = telegram
		self.signal = signal
		self.twitter = twitter
		self.instagram = instagram
		self.facebook = facebook
		self.vkontakte = vkontakte
		self.snapchat = snapchat
		self.discord = discord
		self.mastodon = mastodon
		self.pixelfed = pixelfed
		self.phoneNumber = phoneNumber
		self.email = email
		self.git = git
		self.site = site
		self.activities = activities
		self.interests = interests
		self.music = music
		self.movies = movies
		self.tv = tv
		self.books = books
		self.games = games
		self.quotes = quotes
		self.about = about
		self.personal = personal
		self.online = online
		self.onlineMobile = onlineMobile
		self.lastSeen = lastSeen
		self.blocked = blocked
		self.blockedByMe = blockedByMe
		self.canPost = canPost
		self.canSeeAllPosts = canSeeAllPosts
		self.canSendFriendRequest = canSendFriendRequest
		self.canWritePrivateMessage = canWritePrivateMessage
		self.mutualCount = mutualCount
		self.friendStatus = friendStatus
		self.isFriend = isFriend
		self.isFavorite = isFavorite
		self.lists = lists
		self.isHiddenFromFeed = isHiddenFromFeed
		self.followersCount = followersCount
		self.isNoIndex = isNoIndex
		self.wallDefault = wallDefault
		self.photo50 = photo50
		self.photo100 = photo100
		self.photo200 = photo200
		self.photo400 = photo400
		self.photoMax = photoMax
		self.photo200Orig = photo200Orig
		self.photo400Orig = photo400Orig
		self.photoMaxOrig = photoMaxOrig
		self.photoId = photoId
		self.timezone = timezone
		self.firstNameNom = firstNameNom
		self.nicknameNom = nicknameNom
		self.lastNameNom = lastNameNom
		self.firstNameGen = firstNameGen
		self.nicknameGen = nicknameGen
		self.lastNameGen = lastNameGen
		self.firstNameDat = firstNameDat
		self.nicknameDat = nicknameDat
		self.lastNameDat = lastNameDat
		self.firstNameAcc = firstNameAcc
		self.nicknameAcc = nicknameAcc
		self.lastNameAcc = lastNameAcc
		self.firstNameIns = firstNameIns
		self.nicknameIns = nicknameIns
		self.lastNameIns = lastNameIns
		self.firstNameAbl = firstNameAbl
		self.nicknameAbl = nicknameAbl
		self.lastNameAbl = lastNameAbl
		self.counters = counters
	}

	private enum CodingKeys: String, CodingKey {
		case id
		case firstName = "first_name"
		case lastName = "last_name"
		case deactivated
		case activityPubID = "ap_id"
		case domain
		case screenName = "screen_name"
		case status
		case url
		case nickname
		case maidenName = "maiden_name"
		case sex
		case birthday = "bdate"
		case homeTown = "home_town"
		case relation
		case relationPartner = "relation_partner"
		case customProfileFields = "custom"
		case city
		case matrix
		case xmpp
		case telegram
		case signal
		case twitter
		case instagram
		case facebook
		case vkontakte
		case snapchat
		case discord
		case mastodon
		case pixelfed
		case phoneNumber = "phone_number"
		case email
		case git
		case site
		case activities
		case interests
		case music
		case movies
		case tv
		case books
		case games
		case quotes
		case about
		case personal
		case online
		case onlineMobile = "online_mobile"
		case lastSeen = "last_seen"
		case blocked
		case blockedByMe = "blocked_by_me"
		case canPost = "can_post"
		case canSeeAllPosts = "can_see_all_posts"
		case canSendFriendRequest = "can_send_friend_request"
		case canWritePrivateMessage = "can_write_private_message"
		case mutualCount = "mutual_count"
		case friendStatus = "friend_status"
		case isFriend = "is_friend"
		case isFavorite = "is_favorite"
		case lists
		case isHiddenFromFeed = "is_hidden_from_feed"
		case followersCount = "followers_count"
		case isNoIndex = "is_no_index"
		case wallDefault = "wall_default"
		case photo50 = "photo_50"
		case photo100 = "photo_100"
		case photo200 = "photo_200"
		case photo400 = "photo_400"
		case photoMax = "photo_max"
		case photo200Orig = "photo_200_orig"
		case photo400Orig = "photo_400_orig"
		case photoMaxOrig = "photo_max_orig"
		case photoId = "photo_id"
		case timezone
		case firstNameNom = "first_name_nom"
		case nicknameNom = "nickname_nom"
		case lastNameNom = "last_name_nom"
		case firstNameGen = "first_name_gen"
		case nicknameGen = "nickname_gen"
		case lastNameGen = "last_name_gen"
		case firstNameDat = "first_name_dat"
		case nicknameDat = "nickname_dat"
		case lastNameDat = "last_name_dat"
		case firstNameAcc = "first_name_acc"
		case nicknameAcc = "nickname_acc"
		case lastNameAcc = "last_name_acc"
		case firstNameIns = "first_name_ins"
		case nicknameIns = "nickname_ins"
		case lastNameIns = "last_name_ins"
		case firstNameAbl = "first_name_abl"
		case nicknameAbl = "nickname_abl"
		case lastNameAbl = "last_name_abl"
		case counters
	}
}