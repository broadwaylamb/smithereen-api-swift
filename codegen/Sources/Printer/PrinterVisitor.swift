import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftParser

struct PrinterVisitor {
	func printFile(_ def: FileDef) -> SourceFileSyntax {
		SourceFileSyntax(leadingTrivia: [.lineComment("// This file is automatically generated. DO NOT EDIT!"), .newlines(2)]) {
			ImportDeclSyntax(
				path: [ImportPathComponentSyntax(name: .identifier("Foundation"))],
			)
			ImportDeclSyntax(
				path: [ImportPathComponentSyntax(name: .identifier("SmithereenAPIInternals"))],
			)

			for decl in def.decls {
				decl.accept(self)
			}
		}
	}

	func printStruct(_ def: StructDef) -> StructDeclSyntax {
		let fields = def.fields
		return StructDeclSyntax(
			leadingTrivia: def.leadingTriviaForTypeDecl,
			modifiers: [DeclModifierSyntax(name: .keyword(.public))],
			name: .identifier(def.name),
			inheritanceClause: InheritanceClauseSyntax {
				for supertype in def.conformances {
					InheritedTypeSyntax(type: supertype.syntax)
				}
				if fields.contains(where: { $0.isIdentifier }) {
					InheritedTypeSyntax(type: TypeSyntax("Identifiable"))
				}
			}
		) {
			for decl in def.decls {
				decl.accept(self)
			}

			InitializerDeclSyntax(
				leadingTrivia: .newlines(2),
				modifiers: [DeclModifierSyntax(name: .keyword(.public))],
				signature: FunctionSignatureSyntax(
					parameterClause: FunctionParameterClauseSyntax {
						for (i, field) in fields.enumerated() {
							FunctionParameterSyntax(
								leadingTrivia: fields.count > 1 ? .newline : nil,
								firstName: .identifier(field.swiftName),
								type: field.type.syntax,
								defaultValue: field.type.isOptional ? InitializerClauseSyntax(value: NilLiteralExprSyntax()) : nil,
								trailingComma: fields.count > 1 ? .commaToken() : nil,
								trailingTrivia: fields.count > 1 && i == fields.endIndex - 1 ? .newline : nil,
							)
						}
					}
				)
			) {
				for field in fields {
					InfixOperatorExprSyntax(
						leftOperand: MemberAccessExprSyntax(
							base: DeclReferenceExprSyntax(baseName: .identifier("self")),
							declName: DeclReferenceExprSyntax(baseName: .identifier(field.swiftName))
						),
						operator: AssignmentExprSyntax(),
						rightOperand: DeclReferenceExprSyntax(baseName: .identifier(field.swiftName))
					)
				}
			}

			if let identifierField = fields.first(where: { $0.isIdentifier }), identifierField.swiftName != "id" {
				DeclSyntax("public var id: \(identifierField.type.syntax) { return \(raw: identifierField.swiftName) }")
			}

			let needsCodingKeys = fields.contains { $0.requiresCustomCodingKey }
			if needsCodingKeys {
				codingKeys(for: fields)
			}
		}
	}

	private func codingKeys(
		for entities: [any HasSerialName],
	) -> EnumDeclSyntax {
		let inheritanceClause = InheritanceClauseSyntax {
			InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("String")))
			InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("CodingKey")))
		}
		return EnumDeclSyntax(leadingTrivia: .newlines(2), modifiers: [DeclModifierSyntax(name: .keyword(.private))], name: .identifier("CodingKeys"), inheritanceClause: inheritanceClause) {
			for entity in entities {
				enumCase(entity, hasDoc: false)
			}
		}
	}

	func printField(_ def: FieldDef) -> VariableDeclSyntax {
		let attributes = AttributeListSyntax {
			for wrapper in def.propertyWrappers {
				AttributeSyntax(attributeName: IdentifierTypeSyntax(name: .identifier(wrapper)), trailingTrivia: .newline)
			}
		}
		return property(
			leadingTrivia: def.leadingTrivia(alwaysSeparate: !attributes.isEmpty),
			attributes: attributes,
			name: def.swiftName,
			modifiers: .public,
			bindingSpecifier: .var,
			type: def.type.syntax,
		)
	}

	func printEnum<RawValue>(_ def: EnumDef<RawValue>) -> any DeclSyntaxProtocol {
		let rawValueType = IdentifierTypeSyntax(name: .identifier("\(RawValue.self)"))
		if def.isFrozen {
			return EnumDeclSyntax(
				leadingTrivia: def.leadingTriviaForTypeDecl,
				modifiers: [DeclModifierSyntax(name: .keyword(.public))],
				name: .identifier(def.name),
				inheritanceClause: InheritanceClauseSyntax {
					InheritedTypeSyntax(type: rawValueType)
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Codable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Sendable")))
				}
			) {
				for `case` in def.cases {
					let rawValue: (any ExprSyntaxProtocol)? = switch `case` {
					case let c as EnumCaseDef<String>:
						c.requiresCustomCodingKey
							? StringLiteralExprSyntax(content: c.serialName)
							: nil
					case let c as EnumCaseDef<Int>:
						IntegerLiteralExprSyntax(integerLiteral: c.rawValue)
					default:
						fatalError("Unsupported enum raw value type")
					}
					EnumCaseDeclSyntax {
						EnumCaseElementSyntax(
							leadingTrivia: `case`.leadingTrivia,
							name: .identifier(`case`.swiftName),
							rawValue: rawValue.map {
								InitializerClauseSyntax(value: $0)
							}
						)
					}
				}
			}
		} else {
			return StructDeclSyntax(
				leadingTrivia: def.leadingTriviaForTypeDecl,
				modifiers: [DeclModifierSyntax(name: .keyword(.public))],
				name: .identifier(def.name),
				inheritanceClause: InheritanceClauseSyntax {
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Hashable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("RawRepresentable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("CaseIterable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Codable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Sendable")))
				},
			) {
				property(name: "rawValue", modifiers: .public, bindingSpecifier: .var, type: rawValueType)
				DeclSyntax("""
				public init(rawValue: \(rawValueType)) {
					self.rawValue = rawValue
				}
				""")
				for (i, `case`) in def.cases.enumerated() {
					let leadingTrivia = if `case`.doc == nil && i == 0 {
						Trivia.newlines(2)
					} else {
						`case`.leadingTrivia
					}
					let initializer: ExprSyntax = switch `case` {
					case let c as EnumCaseDef<String>:
						"Self(rawValue: \(StringLiteralExprSyntax(content: c.serialName)))"
					case let c as EnumCaseDef<Int>:
						"Self(rawValue: \(IntegerLiteralExprSyntax(integerLiteral: c.rawValue)))"
					default:
						fatalError("Unsupported enum raw value type")
					}
					property(
						leadingTrivia: leadingTrivia,
						name: `case`.swiftName, 
						modifiers: .public, .static,
						bindingSpecifier: .let,
						type: nil as TypeSyntax?,
						initializer: initializer,
					)
				}

				property(
					leadingTrivia: .newlines(2),
					name: "allCases",
					modifiers: .public, .static,
					bindingSpecifier: .let,
					type: TypeSyntax(ArrayTypeSyntax(element: IdentifierTypeSyntax(name: .identifier(def.name)))),
					initializer: ExprSyntax(
						ArrayExprSyntax {
							for (i, `case`) in def.cases.enumerated() {
								ArrayElementSyntax(
									leadingTrivia: .newline,
									expression: MemberAccessExprSyntax(
										name: identifier(`case`.swiftName, context: .memberAccess),
									),
									trailingComma: .commaToken(),
									trailingTrivia: i == def.cases.endIndex - 1 ? .newline : nil,
								)
							}
						}
					)
				)

				if def.hasAdditionalIntRepresentation {
					initFromDecoderDecl {
						"let container = try decoder.singleValueContainer()"
						DoStmtSyntax.init(
							catchClauses: CatchClauseListSyntax {
								CatchClauseSyntax("catch DecodingError.typeMismatch") {
									"let intValue = try container.decode(Int.self)"
									try! SwitchExprSyntax("switch intValue") {
										for `case` in def.cases {
											if let intValue = `case`.additionalRepresentation {
												SwitchCaseSyntax("case \(raw: intValue): self = .\(DeclReferenceExprSyntax(baseName: identifier(`case`.swiftName, context: .memberAccess)))")
											}
										}
										SwitchCaseSyntax("default: self = Self(rawValue: String(intValue))")
									}
								}
							}
						) {
							"self = Self(rawValue: try container.decode(String.self))"
						}
					}
				}
			}
		}
	}

	func printTaggedUnion(_ def: TaggedUnionDef) -> EnumDeclSyntax {
		EnumDeclSyntax(
			leadingTrivia: def.leadingTriviaForTypeDecl,
			modifiers: [DeclModifierSyntax(name: .keyword(.public))],
			name: .identifier(def.name),
			inheritanceClause: InheritanceClauseSyntax {
				InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Hashable")))
				InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Codable")))
				InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Sendable")))
			}
		) {
			for variant in def.variants {
				enumCase(variant, payload: variant.type)
			}
			
			enumCase(
				leadingTrivia: docComment("Represents an unrecognized type of payload."), 
				name: "unknown",
				payload: .string,
			)

			codingKeys(for: [CustomCodingKey(serialName: "type")] + def.variants)

			initFromDecoderDecl {
				"let container = try decoder.container(keyedBy: CodingKeys.self)"
        		"let type = try container.decode(String.self, forKey: .type)"
				try! SwitchExprSyntax("switch type") {
					for variant in def.variants {
						let caseName = variant.swiftIdentifier(for: .memberAccess)
						SwitchCaseSyntax("""
							case CodingKeys.\(caseName).stringValue:
								self = .\(caseName)(try container.decode(\(variant.type.syntax).self, forKey: .\(caseName)))
							""")
					}
					SwitchCaseSyntax("""
						default:
							self = .unknown(type)
						""")
				}
			}

			try! FunctionDeclSyntax("public func encode(to encoder: any Encoder) throws") {
				"var container = encoder.container(keyedBy: CodingKeys.self)"
				"let tag: String"
				try! SwitchExprSyntax("switch self") {
					for variant in def.variants {
						let caseName = variant.swiftIdentifier(for: .memberAccess)
						SwitchCaseSyntax("""
							case .\(caseName)(let payload):
								tag = CodingKeys.\(caseName).stringValue
								try container.encode(payload, forKey: .\(caseName))
							""")
					}
					SwitchCaseSyntax("""
						case .unknown(let _tag):
							tag = _tag
						""")
				}
				"try container.encode(tag, forKey: .type)"
			}
		}
	}
}

private struct CustomCodingKey: HasSerialName {
	var serialName: String
	var customSwiftName: String?
}

extension EnumDef {
	fileprivate var hasAdditionalIntRepresentation: Bool {
		cases.contains { $0.additionalRepresentation != nil }
	}
}

extension HasSerialName {
	fileprivate var requiresCustomCodingKey: Bool {
		swiftName != serialName
	}
}

extension TypeRef {
	fileprivate var syntax: TypeSyntax {
		let id = IdentifierTypeSyntax(name: .identifier(name))
		if isOptional {
			return TypeSyntax(OptionalTypeSyntax(wrappedType: id))
		} else {
			return TypeSyntax(id)
		}
	}
}

private func docComment(_ text: String) -> Trivia {
	var pieces: [TriviaPiece] = [.newlines(2)]
	for line in text.split(separator: "\n") {
		pieces.append(.docLineComment("/// " + line))
		pieces.append(.newlines(1))
	}
	return Trivia(pieces: pieces)
}

extension Documentable {
	fileprivate var leadingTrivia: Trivia? {
		doc.map(docComment)
	}

	fileprivate var leadingTriviaForTypeDecl: Trivia {
		leadingTrivia(alwaysSeparate: true)!
	}

	fileprivate func leadingTrivia(alwaysSeparate: Bool) -> Trivia? {
		leadingTrivia ?? (alwaysSeparate ? .newlines(2) : nil)
	}
}

extension HasSerialName {
	fileprivate func swiftIdentifier(for context: IdentifierCheckContext) -> TokenSyntax {
		identifier(swiftName, context: context)
	}
}

private func identifier(
	_ name: String,
	 context: IdentifierCheckContext,
) -> TokenSyntax {
	if name.isValidSwiftIdentifier(for: context) {
		return .identifier(name)
	}
	return .identifier("`\(name)`")
}

private func property(
	leadingTrivia: Trivia? = nil,
	attributes: AttributeListSyntax = [],
	name: String,
	modifiers: Keyword...,
	bindingSpecifier: Keyword,
	type: (some TypeSyntaxProtocol)? = nil,
	initializer: ExprSyntax? = nil,
) -> VariableDeclSyntax {
	VariableDeclSyntax(
		leadingTrivia: leadingTrivia,
		attributes: attributes,
		modifiers: DeclModifierListSyntax(modifiers.map { DeclModifierSyntax(name: .keyword($0)) }),
		bindingSpecifier: .keyword(bindingSpecifier),
	) {
		PatternBindingSyntax(
			pattern: IdentifierPatternSyntax(identifier: identifier(name, context: .variableName)),
			typeAnnotation: type.map { TypeAnnotationSyntax(type: $0) },
			initializer: initializer.map { InitializerClauseSyntax(value: $0) },
		)
	}
}

private func initFromDecoderDecl(
	@CodeBlockItemListBuilder bodyBuilder: () throws -> CodeBlockItemListSyntax?
) rethrows -> InitializerDeclSyntax {
	try InitializerDeclSyntax(
		leadingTrivia: .newlines(2),
		modifiers: [DeclModifierSyntax(name: .keyword(.public))],
		signature: FunctionSignatureSyntax(
			parameterClause: FunctionParameterClauseSyntax(
				parameters: [
					FunctionParameterSyntax(
						firstName: .identifier("from"),
						secondName: .identifier("decoder"),
						type: TypeSyntax("Decoder")
					)
				]
			),
			effectSpecifiers: FunctionEffectSpecifiersSyntax(
				throwsClause: ThrowsClauseSyntax(throwsSpecifier: .keyword(.throws))
			)
		),
		bodyBuilder: bodyBuilder
	)
}

private func enumCase(
	_ entity: any HasSerialName,
	hasDoc: Bool = true,
	payload: TypeRef? = nil,
) -> EnumCaseDeclSyntax {
	let leadingTrivia: Trivia? = if let entity = entity as? Documentable, hasDoc {
		entity.leadingTrivia
	} else {
		nil
	}
	return enumCase(
		leadingTrivia: leadingTrivia,
		name: entity.swiftName,
		rawValue: payload == nil && entity.requiresCustomCodingKey 
			? entity.serialName 
			: nil,
		payload: payload,
	)
}

private func enumCase(
	leadingTrivia: Trivia?,
	name: String,
	rawValue: String? = nil,
	payload: TypeRef? = nil,
) -> EnumCaseDeclSyntax {
	EnumCaseDeclSyntax(leadingTrivia: leadingTrivia) {
		EnumCaseElementSyntax(
			name: identifier(name, context: .variableName),
			parameterClause: payload.map { payload in
				EnumCaseParameterClauseSyntax(
					parameters: EnumCaseParameterListSyntax {
						EnumCaseParameterSyntax(type: payload.syntax)
					}
				)
			},
			rawValue: rawValue.map {
				InitializerClauseSyntax(value: StringLiteralExprSyntax(content: $0))
			}
		)
	}
}
