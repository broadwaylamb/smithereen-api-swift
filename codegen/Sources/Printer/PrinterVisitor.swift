import SwiftSyntax
import SwiftSyntaxBuilder

struct PrinterVisitor {
	func printFile(_ def: FileDef) -> SourceFileSyntax {
		SourceFileSyntax(leadingTrivia: [.lineComment("// This file is automatically generated. DO NOT EDIT!"), .newlines(2)]) {
			ImportDeclSyntax(
				path: [ImportPathComponentSyntax(name: .identifier("Foundation"))],
			)
			ImportDeclSyntax(
				path: [ImportPathComponentSyntax(name: .identifier("SmithereenAPIInternals"))],
			)

			for decl in def.decls {
				decl.accept(self)
			}
		}
	}

	func printStruct(_ def: StructDef) -> StructDeclSyntax {
		let fields = def.fields
		return StructDeclSyntax(
			leadingTrivia: def.leadingTriviaForTypeDecl,
			modifiers: [DeclModifierSyntax(name: .keyword(.public))],
			name: .identifier(def.name),
			inheritanceClause: InheritanceClauseSyntax {
				for supertype in def.conformances {
					InheritedTypeSyntax(type: supertype.syntax)
				}
				if fields.contains(where: { $0.isIdentifier }) {
					InheritedTypeSyntax(type: TypeSyntax("Identifiable"))
				}
			}
		) {
			for decl in def.decls {
				decl.accept(self)
			}

			InitializerDeclSyntax(
				leadingTrivia: .newlines(2),
				modifiers: [DeclModifierSyntax(name: .keyword(.public))],
				signature: FunctionSignatureSyntax(
					parameterClause: FunctionParameterClauseSyntax {
						for (i, field) in fields.enumerated() {
							FunctionParameterSyntax(
								leadingTrivia: fields.count > 1 ? .newline : nil,
								firstName: .identifier(field.swiftName),
								type: field.type.syntax,
								defaultValue: field.type.isOptional ? InitializerClauseSyntax(value: NilLiteralExprSyntax()) : nil,
								trailingComma: fields.count > 1 ? .commaToken() : nil,
								trailingTrivia: fields.count > 1 && i == fields.endIndex - 1 ? .newline : nil,
							)
						}
					}
				)
			) {
				for field in fields {
					InfixOperatorExprSyntax(
						leftOperand: MemberAccessExprSyntax(
							base: DeclReferenceExprSyntax(baseName: .identifier("self")),
							declName: DeclReferenceExprSyntax(baseName: .identifier(field.swiftName))
						),
						operator: AssignmentExprSyntax(),
						rightOperand: DeclReferenceExprSyntax(baseName: .identifier(field.swiftName))
					)
				}
			}

			if let identifierField = fields.first(where: { $0.isIdentifier }), identifierField.swiftName != "id" {
				DeclSyntax("public var id: \(identifierField.type.syntax) { return \(raw: identifierField.swiftName) }")
			}

			let needsCodingKeys = fields.contains { $0.requiresCustomCodingKey }
			if needsCodingKeys {
				let inheritanceClause = InheritanceClauseSyntax {
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("String")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("CodingKey")))
				}
				EnumDeclSyntax(leadingTrivia: .newlines(2), modifiers: [DeclModifierSyntax(name: .keyword(.private))], name: .identifier("CodingKeys"), inheritanceClause: inheritanceClause) {
					for field in fields {
						EnumCaseDeclSyntax {
							EnumCaseElementSyntax(
								name: .identifier(field.swiftName),
								rawValue: field.requiresCustomCodingKey
									? InitializerClauseSyntax(value: StringLiteralExprSyntax(content: field.serialName))
									: nil
							)
						}
					}
				}
			}
		}
	}

	func printField(_ def: FieldDef) -> VariableDeclSyntax {
		let attributes = AttributeListSyntax {
			for wrapper in def.propertyWrappers {
				AttributeSyntax(attributeName: IdentifierTypeSyntax(name: .identifier(wrapper)), trailingTrivia: .newline)
			}
		}
		return property(
			leadingTrivia: def.leadingTrivia(alwaysSeparate: !attributes.isEmpty),
			attributes: attributes,
			name: def.swiftName,
			modifiers: .public,
			bindingSpecifier: .var,
			type: def.type.syntax,
		)
	}

	func printEnum(_ def: EnumDef) -> any DeclSyntaxProtocol {
		if def.isFrozen {
			return EnumDeclSyntax(
				leadingTrivia: def.leadingTriviaForTypeDecl,
				modifiers: [DeclModifierSyntax(name: .keyword(.public))],
				name: .identifier(def.name),
				inheritanceClause: InheritanceClauseSyntax {
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("String")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Codable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Sendable")))
				}
			) {
				for `case` in def.cases {
					EnumCaseDeclSyntax {
						EnumCaseElementSyntax(
							leadingTrivia: `case`.leadingTrivia,
							name: .identifier(`case`.swiftName),
							rawValue: `case`.requiresCustomCodingKey
								? InitializerClauseSyntax(value: StringLiteralExprSyntax(content: `case`.serialName))
								: nil
						)
					}
				}
			}
		} else {
			return StructDeclSyntax(
				leadingTrivia: def.leadingTriviaForTypeDecl,
				modifiers: [DeclModifierSyntax(name: .keyword(.public))],
				name: .identifier(def.name),
				inheritanceClause: InheritanceClauseSyntax {
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Hashable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("RawRepresentable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("CaseIterable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Codable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Sendable")))
				},
			) {
				property(name: "rawValue", modifiers: .public, bindingSpecifier: .var, type: "String")
				DeclSyntax("""
				public init(rawValue: String) {
					self.rawValue = rawValue
				}
				""")
				for (i, `case`) in def.cases.enumerated() {
					let leadingTrivia = if `case`.doc == nil && i == 0 {
						Trivia.newlines(2)
					} else {
						`case`.leadingTrivia
					}
					property(
						leadingTrivia: leadingTrivia,
						name: `case`.swiftName, 
						modifiers: .public, .static,
						bindingSpecifier: .let,
						initializer: "Self(rawValue: \(StringLiteralExprSyntax(content: `case`.serialName)))"
					)
				}

				property(
					leadingTrivia: .newlines(2),
					name: "allCases",
					modifiers: .public, .static,
					bindingSpecifier: .let,
					type: TypeSyntax(ArrayTypeSyntax(element: IdentifierTypeSyntax(name: .identifier(def.name)))),
					initializer: ExprSyntax(
						ArrayExprSyntax {
							for (i, `case`) in def.cases.enumerated() {
								ArrayElementSyntax(
									leadingTrivia: .newline,
									expression: MemberAccessExprSyntax(
										name: .identifier(`case`.swiftName),
									),
									trailingComma: .commaToken(),
									trailingTrivia: i == def.cases.endIndex - 1 ? .newline : nil,
								)
							}
						}
					)
				)

				if def.hasAdditionalIntRepresentation {
					initFromDecoderDecl {
						"let container = try decoder.singleValueContainer()"
						DoStmtSyntax.init(
							catchClauses: CatchClauseListSyntax {
								CatchClauseSyntax("catch DecodingError.typeMismatch") {
									"let intValue = try container.decode(Int.self)"
									try! SwitchExprSyntax("switch intValue") {
										for `case` in def.cases {
											if let intValue = `case`.additionalRepresentation {
												SwitchCaseSyntax("case \(raw: intValue): self = .\(DeclReferenceExprSyntax(baseName: .identifier(`case`.swiftName)))")
											}
										}
										SwitchCaseSyntax("default: self = Self(rawValue: String(intValue))")
									}
								}
							}
						) {
							"self = Self(rawValue: try container.decode(String.self))"
						}
					}
				}
			}
		}
	}
}

extension EnumDef {
	fileprivate var hasAdditionalIntRepresentation: Bool {
		cases.contains { $0.additionalRepresentation != nil }
	}
}

extension HasSerialName {
	fileprivate var requiresCustomCodingKey: Bool {
		swiftName != serialName
	}
}

extension TypeRef {
	fileprivate var syntax: TypeSyntax {
		let id = IdentifierTypeSyntax(name: .identifier(name))
		if isOptional {
			return TypeSyntax(OptionalTypeSyntax(wrappedType: id))
		} else {
			return TypeSyntax(id)
		}
	}
}

extension Documentable {
	fileprivate var leadingTrivia: Trivia? {
		guard let doc else { return nil }
		var pieces: [TriviaPiece] = [.newlines(2)]
		for line in doc.split(separator: "\n") {
			pieces.append(.docLineComment("/// " + line))
			pieces.append(.newlines(1))
		}
		return Trivia(pieces: pieces)
	}

	fileprivate var leadingTriviaForTypeDecl: Trivia {
		leadingTrivia(alwaysSeparate: true)!
	}

	fileprivate func leadingTrivia(alwaysSeparate: Bool) -> Trivia? {
		leadingTrivia ?? (alwaysSeparate ? .newlines(2) : nil)
	}
}

private func property(
	leadingTrivia: Trivia? = nil,
	attributes: AttributeListSyntax = [],
	name: String,
	modifiers: Keyword...,
	bindingSpecifier: Keyword,
	type: TypeSyntax? = nil,
	initializer: ExprSyntax? = nil,
) -> VariableDeclSyntax {
	VariableDeclSyntax(
		leadingTrivia: leadingTrivia,
		attributes: attributes,
		modifiers: DeclModifierListSyntax(modifiers.map { DeclModifierSyntax(name: .keyword($0)) }),
		bindingSpecifier: .keyword(bindingSpecifier),
	) {
		PatternBindingSyntax(
			pattern: IdentifierPatternSyntax(identifier: .identifier(name)),
			typeAnnotation: type.map { TypeAnnotationSyntax(type: $0) },
			initializer: initializer.map { InitializerClauseSyntax(value: $0) },
		)
	}
}

private func initFromDecoderDecl(
	@CodeBlockItemListBuilder bodyBuilder: () throws -> CodeBlockItemListSyntax?
) rethrows -> InitializerDeclSyntax {
	try InitializerDeclSyntax(
		leadingTrivia: .newlines(2),
		modifiers: [DeclModifierSyntax(name: .keyword(.public))],
		signature: FunctionSignatureSyntax(
			parameterClause: FunctionParameterClauseSyntax(
				parameters: [
					FunctionParameterSyntax(
						firstName: .identifier("from"),
						secondName: .identifier("decoder"),
						type: TypeSyntax("Decoder")
					)
				]
			),
			effectSpecifiers: FunctionEffectSpecifiersSyntax(
				throwsClause: ThrowsClauseSyntax(throwsSpecifier: .keyword(.throws))
			)
		),
		bodyBuilder: bodyBuilder
	)
}
