import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftParser

final class PrinterVisitor {
	func printFile(_ def: FileDef) -> SourceFileSyntax {
		SourceFileSyntax(leadingTrivia: [.lineComment("// This file is automatically generated. DO NOT EDIT!"), .newlines(2)]) {
			ImportDeclSyntax(
				path: [ImportPathComponentSyntax(name: .identifier("Foundation"))],
			)
			ImportDeclSyntax(
				path: [ImportPathComponentSyntax(name: .identifier("SmithereenAPIInternals"))],
			)
			for additionalImport in def.additionalImports {
				ImportDeclSyntax(
					path: [ImportPathComponentSyntax(name: .identifier(additionalImport))],
				)
			}

			for decl in def.decls {
				decl.accept(self)
			}
		}
	}

	func printStruct(_ def: StructDef) -> any DeclSyntaxProtocol {
		printStruct(def, additionalDeclarations: {})
	}

	private func printStruct(
		_ def: StructDef,
		@MemberBlockItemListBuilder additionalDeclarations: () -> MemberBlockItemListSyntax,
	) -> any DeclSyntaxProtocol {
		let nameComponents = def.name.split(separator: ".")
		let fields = def.fields
		let structSyntax = StructDeclSyntax(
			leadingTrivia: def.leadingTriviaForTypeDecl,
			modifiers: [DeclModifierSyntax(name: .keyword(.public))],
			name: .identifier(String(nameComponents.last!)),
			genericParameterClause: def.typeParameters.isEmpty
				? nil
				: GenericParameterClauseSyntax {
					for tp in def.typeParameters {
						GenericParameterSyntax(
							name: identifier(tp.name, context: .variableName),
							colon: tp.upperBound.map { _ in .colonToken() },
							inheritedType: tp.upperBound?.syntax,
						)
					}
				},
			inheritanceClause: InheritanceClauseSyntax {
				for supertype in def.conformances {
					InheritedTypeSyntax(type: supertype.syntax)
				}
				if fields.contains(where: { $0.isIdentifier }) {
					InheritedTypeSyntax(type: TypeSyntax("Identifiable"))
				}
			}
		) {
			for decl in def.decls {
				decl.accept(self)
			}

			InitializerDeclSyntax(
				leadingTrivia: .newlines(2),
				modifiers: [DeclModifierSyntax(name: .keyword(.public))],
				signature: FunctionSignatureSyntax(
					parameterClause: parametersForFields(fields)
				)
			) {
				for field in fields where field.constantValue == nil {
					InfixOperatorExprSyntax(
						leftOperand: MemberAccessExprSyntax(
							base: DeclReferenceExprSyntax(baseName: .identifier("self")),
							declName: DeclReferenceExprSyntax(baseName: .identifier(field.swiftName))
						),
						operator: AssignmentExprSyntax(),
						rightOperand: DeclReferenceExprSyntax(baseName: .identifier(field.swiftName))
					)
				}
			}

			if let identifierField = fields.first(where: { $0.isIdentifier }), identifierField.swiftName != "id" {
				DeclSyntax("public var id: \(identifierField.type.syntax) { return \(raw: identifierField.swiftName) }")
			}

			let needsCustomCoding = fields.contains { $0.isFlattened }
			let needsCodingKeys =
				needsCustomCoding || fields.contains { $0.requiresCustomCodingKey }
			let nonFlattenedFields = fields.filter { !$0.isFlattened }
			if needsCodingKeys && !nonFlattenedFields.isEmpty {
				codingKeys(for: nonFlattenedFields)
			}

			if needsCustomCoding {
				if def.conformances.contains(.encodable) || def.conformances.contains(.codable) {
					try! FunctionDeclSyntax("public func encode(to encoder: any Encoder) throws") {
						let allFieldsAreFlattened = fields.allSatisfy { $0.isFlattened }
						if !allFieldsAreFlattened {
							"var container = encoder.container(keyedBy: CodingKeys.self)"
						}
						for field in fields {
							let fieldIdentifier = field.swiftIdentifier(for: .memberAccess)
							if field.isFlattened {
								let questionMark = field.type.isOptional ? "?" : ""
								"try self.\(fieldIdentifier)\(raw: questionMark).encode(to: encoder)"
							} else {
								let ifPresent = field.type.isOptional ? "IfPresent" : ""
								"try container.encode\(raw: ifPresent)(self.\(fieldIdentifier), forKey: .\(fieldIdentifier))"
							}
						}
					}
				}
				if def.conformances.contains(.decodable) || def.conformances.contains(.codable) {
					initFromDecoderDecl {
						let allFieldsAreFlattened = fields.allSatisfy { $0.isFlattened }
						if !allFieldsAreFlattened {
							"let container = try decoder.container(keyedBy: CodingKeys.self)"
						}
						for field in fields where field.constantValue == nil {
							let fieldIdentifier = field.swiftIdentifier(for: .memberAccess)
							let typeSyntax = field.type.optional(false).syntax
							if field.isFlattened {
								"self.\(fieldIdentifier) = try \(typeSyntax)(from: decoder)"
							} else {
								let ifPresent = field.type.isOptional ? "IfPresent" : ""
								"self.\(fieldIdentifier) = try container.decode\(raw: ifPresent)(\(typeSyntax).self, forKey: .\(fieldIdentifier))"
							}
						}
					}
				}
			}

			additionalDeclarations()
		}

		if nameComponents.count == 1 {
			return structSyntax
		}

		let extendedName = nameComponents
			.dropLast()
			.joined(separator: ".")
		return ExtensionDeclSyntax(
			extendedType: IdentifierTypeSyntax(name: .identifier(extendedName)),
		) {
			structSyntax
		}
	}

	func printRequest(_ def: RequestDef) -> any DeclSyntaxProtocol {
		return printStruct(def.structDef) {
			"public var path: String { \(StringLiteralExprSyntax(content: def.path)) }"
			"public static var method: HTTPMethod { .post }"
			if def.structDef.fields.isEmpty {
				"public var encodableBody: NeverCodable? { nil }"
			} else {
				"public var encodableBody: Self? { self }"
			}
			if let resultType = def.resultType {
				"public typealias Result = \(resultType.syntax)"
			}

			if let extended = def.extended {
				let returnTypeRef = TypeRef.def(extended.request.structDef)
				FunctionDeclSyntax(
					leadingTrivia: .newlines(2),
					modifiers: [DeclModifierSyntax(name: .keyword(.public))],
					name: identifier(
						extended.request.structDef.name.lowercasedFirstChar,
						context: .variableName,
					),
					signature: FunctionSignatureSyntax(
						parameterClause: parametersForFields(extended.newFields),
						returnClause: ReturnClauseSyntax(
							type: returnTypeRef.syntax
						),
					),
				) {
					FunctionCallExprSyntax(
						calledExpression: DeclReferenceExprSyntax(baseName: .identifier(returnTypeRef.name)),
						leftParen: .leftParenToken(),
						rightParen: .rightParenToken(),
					) {
						var isFirst = true
						for field in extended.request.structDef.fields where field.constantValue == nil {
							let id = field.swiftIdentifier(for: .memberAccess)
							LabeledExprSyntax(
								leadingTrivia: isFirst ? .newline : nil,
								label: id,
								colon: .colonToken(),
								expression: DeclReferenceExprSyntax(baseName: id),
								trailingComma: .commaToken(),
								trailingTrivia: .newline,
							)
							let _ = isFirst = false
						}
					}
				}
			}
		}
	}

	private func codingKeys(
		for entities: [any HasSerialName],
	) -> EnumDeclSyntax {
		let inheritanceClause = InheritanceClauseSyntax {
			InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("String")))
			InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("CodingKey")))
		}
		return EnumDeclSyntax(leadingTrivia: .newlines(2), modifiers: [DeclModifierSyntax(name: .keyword(.private))], name: .identifier("CodingKeys"), inheritanceClause: inheritanceClause) {
			for entity in entities {
				enumCase(entity, hasDoc: false)
			}
		}
	}

	func printField(_ def: FieldDef) -> VariableDeclSyntax {
		let attributes = AttributeListSyntax {
			for wrapper in def.propertyWrappers {
				AttributeSyntax(attributeName: IdentifierTypeSyntax(name: .identifier(wrapper)), trailingTrivia: .newline)
			}
		}

		return property(
			leadingTrivia: def.leadingTrivia(alwaysSeparate: !attributes.isEmpty),
			attributes: attributes,
			name: def.swiftName,
			modifiers: def.constantValue == nil ? .public : .private,
			isConstant: def.constantValue != nil,
			type: def.type.syntax,
			initializer: def.constantValue.map { "\(raw: $0)" },
		)
	}

	func printEnum<RawValue>(_ def: EnumDef<RawValue>) -> any DeclSyntaxProtocol {
		let rawValueType = IdentifierTypeSyntax(name: .identifier("\(RawValue.self)"))
		if def.isFrozen {
			return EnumDeclSyntax(
				leadingTrivia: def.leadingTriviaForTypeDecl,
				modifiers: [DeclModifierSyntax(name: .keyword(.public))],
				name: .identifier(def.name),
				inheritanceClause: InheritanceClauseSyntax {
					InheritedTypeSyntax(type: rawValueType)
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Codable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Sendable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("CaseIterable")))
				}
			) {
				for `case` in def.cases {
					let rawValue: (any ExprSyntaxProtocol)? = switch `case` {
					case let c as EnumCaseDef<String>:
						c.requiresCustomCodingKey
							? StringLiteralExprSyntax(content: c.serialName)
							: nil
					case let c as EnumCaseDef<Int>:
						IntegerLiteralExprSyntax(integerLiteral: c.rawValue)
					default:
						fatalError("Unsupported enum raw value type")
					}
					EnumCaseDeclSyntax(leadingTrivia: `case`.leadingTrivia) {
						EnumCaseElementSyntax(
							name: identifier(`case`.swiftName, context: .variableName),
							rawValue: rawValue.map {
								InitializerClauseSyntax(value: $0)
							}
						)
					}
				}
			}
		} else {
			return StructDeclSyntax(
				leadingTrivia: def.leadingTriviaForTypeDecl,
				modifiers: [DeclModifierSyntax(name: .keyword(.public))],
				name: .identifier(def.name),
				inheritanceClause: InheritanceClauseSyntax {
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Hashable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("RawRepresentable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("CaseIterable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Codable")))
					InheritedTypeSyntax(type: IdentifierTypeSyntax(name: .identifier("Sendable")))
				},
			) {
				property(name: "rawValue", modifiers: .public, isConstant: false, type: rawValueType)
				DeclSyntax("""
				public init(rawValue: \(rawValueType)) {
					self.rawValue = rawValue
				}
				""")
				for (i, `case`) in def.cases.enumerated() {
					let leadingTrivia = if `case`.doc == nil && i == 0 {
						Trivia.newlines(2)
					} else {
						`case`.leadingTrivia
					}
					let initializer: ExprSyntax = switch `case` {
					case let c as EnumCaseDef<String>:
						"Self(rawValue: \(StringLiteralExprSyntax(content: c.serialName)))"
					case let c as EnumCaseDef<Int>:
						"Self(rawValue: \(IntegerLiteralExprSyntax(integerLiteral: c.rawValue)))"
					default:
						fatalError("Unsupported enum raw value type")
					}
					property(
						leadingTrivia: leadingTrivia,
						name: `case`.swiftName,
						modifiers: .public, .static,
						isConstant: true,
						type: nil as TypeSyntax?,
						initializer: initializer,
					)
				}

				property(
					leadingTrivia: .newlines(2),
					name: "allCases",
					modifiers: .public, .static,
					isConstant: true,
					type: TypeSyntax(ArrayTypeSyntax(element: IdentifierTypeSyntax(name: .identifier(def.name)))),
					initializer: ExprSyntax(
						ArrayExprSyntax {
							for (i, `case`) in def.cases.enumerated() {
								ArrayElementSyntax(
									leadingTrivia: .newline,
									expression: MemberAccessExprSyntax(
										name: identifier(`case`.swiftName, context: .memberAccess),
									),
									trailingComma: .commaToken(),
									trailingTrivia: i == def.cases.endIndex - 1 ? .newline : nil,
								)
							}
						}
					)
				)

				if def.hasAdditionalIntRepresentation {
					initFromDecoderDecl {
						"let container = try decoder.singleValueContainer()"
						DoStmtSyntax.init(
							catchClauses: CatchClauseListSyntax {
								CatchClauseSyntax("catch DecodingError.typeMismatch") {
									"let intValue = try container.decode(Int.self)"
									try! SwitchExprSyntax("switch intValue") {
										for `case` in def.cases {
											if let intValue = `case`.additionalRepresentation {
												SwitchCaseSyntax("case \(raw: intValue): self = .\(DeclReferenceExprSyntax(baseName: identifier(`case`.swiftName, context: .memberAccess)))")
											}
										}
										SwitchCaseSyntax("default: self = Self(rawValue: String(intValue))")
									}
								}
							}
						) {
							"self = Self(rawValue: try container.decode(String.self))"
						}
					}
				}
			}
		}
	}

	func printTaggedUnion(_ def: TaggedUnionDef) -> EnumDeclSyntax {
		EnumDeclSyntax(
			leadingTrivia: def.leadingTriviaForTypeDecl,
			modifiers: [DeclModifierSyntax(name: .keyword(.public))],
			name: .identifier(def.name),
			inheritanceClause: InheritanceClauseSyntax {
				for supertype in def.conformances {
					InheritedTypeSyntax(type: supertype.syntax)
				}
			}
		) {
			for decl in def.decls {
				decl.accept(self)
			}

			if !def.isFrozen {
				enumCase(
					leadingTrivia: docComment("Represents an unrecognized type of payload."),
					name: "unknown",
					payload: .string,
				)
			}

			var keys = def.variants
				.distinct { $0.payloadFieldName }
				.map { CustomCodingKey(serialName: $0.payloadFieldName) }

			if def.hasTag {
				let _ = keys.insert(CustomCodingKey(serialName: "type"), at: 0)
			}

			codingKeys(for: keys)

			if def.conformances.contains(.decodable) || def.conformances.contains(.codable) {
				initFromDecoderDecl {
					"let container = try decoder.container(keyedBy: CodingKeys.self)"
	        		"let type = try container.decode(String.self, forKey: .type)"
					try! SwitchExprSyntax("switch type") {
						for variant in def.variants {
							let caseName = variant.swiftIdentifier(for: .memberAccess)
							let codingKey = identifier(
								variant.payloadFieldName.convertFromSnakeCase(),
								context: .memberAccess,
							)
							if variant.isFlattened {
								SwitchCaseSyntax("""
									case "\(raw: variant.serialName)":
										self = .\(caseName)(try .init(from: decoder))
									""")
							} else {
								SwitchCaseSyntax("""
									case "\(raw: variant.serialName)":
										self = .\(caseName)(try container.decode(\(variant.type.syntax).self, forKey: .\(codingKey)))
									""")
							}
						}
						if def.isFrozen {
							SwitchCaseSyntax("""
								default:
									throw DecodingError.dataCorruptedError(
										forKey: .type,
										in: container,
										debugDescription: "Unknown payload type",
									)
								""")
						} else {
							SwitchCaseSyntax("""
								default:
									self = .unknown(type)
								""")
						}
					}
				}
			}

			if def.conformances.contains(.encodable) || def.conformances.contains(.codable) {
				try! FunctionDeclSyntax("public func encode(to encoder: any Encoder) throws") {
					"var container = encoder.container(keyedBy: CodingKeys.self)"
					if def.hasTag {
						"let tag: String"
					}
					try! SwitchExprSyntax("switch self") {
						for variant in def.variants {
							let caseName = variant.swiftIdentifier(for: .memberAccess)
							let codingKey = identifier(
								variant.payloadFieldName.convertFromSnakeCase(),
								context: .memberAccess,
							)
							SwitchCaseSyntax("case .\(caseName)(let payload):") {
								if def.hasTag {
									"tag = \"\(raw: variant.serialName)\""
								}
								"try container.encode(payload, forKey: .\(codingKey))"
							}
						}
						if !def.isFrozen && def.hasTag {
							SwitchCaseSyntax("""
								case .unknown(let _tag):
									tag = _tag
								""")
						}
					}
					if def.hasTag {
						"try container.encode(tag, forKey: .type)"
					}
				}
			}
		}
	}

	func printTaggedUnionVariant(_ def: TaggedUnionVariantDef) -> EnumCaseDeclSyntax {
		enumCase(def, payload: def.type)
	}

	private var inProtocol = false

	func printProtocol(_ def: ProtocolDef) -> ProtocolDeclSyntax {
		inProtocol = true
		defer {
			inProtocol = false
		}
		return ProtocolDeclSyntax(
			leadingTrivia: def.leadingTriviaForTypeDecl,
			modifiers: [DeclModifierSyntax(name: .keyword(.public))],
			name: .identifier(def.name),
			inheritanceClause: InheritanceClauseSyntax {
				for supertype in def.conformances {
					InheritedTypeSyntax(type: supertype.syntax)
				}
			}
		) {
			for decl in def.decls {
				decl.accept(self)
			}
		}
	}

	private func property(
		leadingTrivia: Trivia? = nil,
		attributes: AttributeListSyntax = [],
		name: String,
		modifiers: Keyword...,
		isConstant: Bool,
		type: (some TypeSyntaxProtocol)? = nil,
		initializer: ExprSyntax? = nil,
	) -> VariableDeclSyntax {
			VariableDeclSyntax(
				leadingTrivia: leadingTrivia,
				attributes: inProtocol ? [] : attributes,
				modifiers: inProtocol ? [] : DeclModifierListSyntax(modifiers.map { DeclModifierSyntax(name: .keyword($0)) }),
				bindingSpecifier: .keyword(inProtocol || !isConstant ? .var : .let),
			) {
				PatternBindingSyntax(
					pattern: IdentifierPatternSyntax(identifier: identifier(name, context: .variableName)),
					typeAnnotation: type.map { TypeAnnotationSyntax(type: $0) },
					initializer: inProtocol ? nil : initializer.map { InitializerClauseSyntax(value: $0) },
					accessorBlock: inProtocol
						? AccessorBlockSyntax(
							accessors: .accessors(
								AccessorDeclListSyntax {
									AccessorDeclSyntax(accessorSpecifier: .keyword(.get))
									if !isConstant {
										AccessorDeclSyntax(accessorSpecifier: .keyword(.set))
									}
								}
							)
						)
						: nil
				)
			}
	}
}

private struct CustomCodingKey: HasSerialName {
	var serialName: String
	var customSwiftName: String?
}

extension EnumDef {
	fileprivate var hasAdditionalIntRepresentation: Bool {
		cases.contains { $0.additionalRepresentation != nil }
	}
}

extension HasSerialName {
	fileprivate var requiresCustomCodingKey: Bool {
		swiftName != serialName
	}
}

extension TypeRef {
	fileprivate var syntax: TypeSyntax {
		let id = IdentifierTypeSyntax(
			name: .identifier(name),
			genericArgumentClause: arguments.isEmpty
				? nil
				: GenericArgumentClauseSyntax {
					for arg in arguments {
						GenericArgumentSyntax(argument: GenericArgumentSyntax.Argument(arg.syntax))
					}
				}
		)
		if isOptional {
			return TypeSyntax(OptionalTypeSyntax(wrappedType: id))
		} else {
			return TypeSyntax(id)
		}
	}
}

private func docComment(_ text: String) -> Trivia {
	var pieces: [TriviaPiece] = [.newlines(2)]
	for line in text.split(separator: "\n") {
		pieces.append(.docLineComment("/// " + line))
		pieces.append(.newlines(1))
	}
	return Trivia(pieces: pieces)
}

extension Documentable {
	fileprivate var leadingTrivia: Trivia? {
		doc.map(docComment)
	}

	fileprivate var leadingTriviaForTypeDecl: Trivia {
		leadingTrivia(alwaysSeparate: true)!
	}

	fileprivate func leadingTrivia(alwaysSeparate: Bool) -> Trivia? {
		leadingTrivia ?? (alwaysSeparate ? .newlines(2) : nil)
	}
}

extension HasSerialName {
	fileprivate func swiftIdentifier(for context: IdentifierCheckContext) -> TokenSyntax {
		identifier(swiftName, context: context)
	}
}

private func identifier(
	_ name: String,
	 context: IdentifierCheckContext,
) -> TokenSyntax {
	if name.isValidSwiftIdentifier(for: context) {
		return .identifier(name)
	}
	return .identifier("`\(name)`")
}

private func initFromDecoderDecl(
	@CodeBlockItemListBuilder bodyBuilder: () throws -> CodeBlockItemListSyntax?
) rethrows -> InitializerDeclSyntax {
	try InitializerDeclSyntax(
		leadingTrivia: .newlines(2),
		modifiers: [DeclModifierSyntax(name: .keyword(.public))],
		signature: FunctionSignatureSyntax(
			parameterClause: FunctionParameterClauseSyntax(
				parameters: [
					FunctionParameterSyntax(
						firstName: .identifier("from"),
						secondName: .identifier("decoder"),
						type: TypeSyntax("Decoder")
					)
				]
			),
			effectSpecifiers: FunctionEffectSpecifiersSyntax(
				throwsClause: ThrowsClauseSyntax(throwsSpecifier: .keyword(.throws))
			)
		),
		bodyBuilder: bodyBuilder
	)
}

private func enumCase(
	_ entity: any HasSerialName,
	hasDoc: Bool = true,
	payload: TypeRef? = nil,
) -> EnumCaseDeclSyntax {
	let leadingTrivia: Trivia? = if let entity = entity as? Documentable, hasDoc {
		entity.leadingTrivia
	} else {
		nil
	}
	return enumCase(
		leadingTrivia: leadingTrivia,
		name: entity.swiftName,
		rawValue: payload == nil && entity.requiresCustomCodingKey
			? entity.serialName
			: nil,
		payload: payload,
	)
}

private func enumCase(
	leadingTrivia: Trivia?,
	name: String,
	rawValue: String? = nil,
	payload: TypeRef? = nil,
) -> EnumCaseDeclSyntax {
	EnumCaseDeclSyntax(leadingTrivia: leadingTrivia) {
		EnumCaseElementSyntax(
			name: identifier(name, context: .variableName),
			parameterClause: payload.map { payload in
				EnumCaseParameterClauseSyntax(
					parameters: EnumCaseParameterListSyntax {
						EnumCaseParameterSyntax(type: payload.syntax)
					}
				)
			},
			rawValue: rawValue.map {
				InitializerClauseSyntax(value: StringLiteralExprSyntax(content: $0))
			}
		)
	}
}

private func parametersForFields(_ fields: [FieldDef]) -> FunctionParameterClauseSyntax {
	let fields = fields.filter { $0.constantValue == nil }
	return FunctionParameterClauseSyntax {
		for (i, field) in fields.enumerated() {
			FunctionParameterSyntax(
				leadingTrivia: fields.count > 1 ? .newline : nil,
				firstName: .identifier(field.swiftName),
				type: field.type.syntax,
				defaultValue: field.type.isOptional ? InitializerClauseSyntax(value: NilLiteralExprSyntax()) : nil,
				trailingComma: fields.count > 1 ? .commaToken() : nil,
				trailingTrivia: fields.count > 1 && i == fields.endIndex - 1 ? .newline : nil,
			)
		}
	}
}
